import SceneWithModel from "~/components/3d/SceneWithModel";
import { loadBlobFromLocalStorage } from "../utils/saveBlob";
import { useWallet, useConnection } from "@solana/wallet-adapter-react";
import { clusterApiUrl, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL, Connection } from "@solana/web3.js";
import { useState, useEffect, ChangeEvent } from "react";
import { useFetcher } from "@remix-run/react";
import Header from "~/components/header";
import type { ActionFunctionArgs } from "@remix-run/node";
import * as Tabs from '@radix-ui/react-tabs';
import { NftMetadata } from "~/types/nft";

interface ActionData {
    imageUrl?: string;
}

/**
 * Returns the PublicKey of the treasury address.
 * Works both in the browser (`import.meta.env`) and on the server (`process.env`).
 * Throws a clear error if the env variable is missing.
 */
function getTreasury(): PublicKey {
    const addr =
        (typeof window !== "undefined"
            ? (import.meta as any).env?.VITE_TREASURY_ADDRESS
            : process.env.VITE_TREASURY_ADDRESS) as string | undefined;

    if (!addr) {
        throw new Error(
            "VITE_TREASURY_ADDRESS env variable is missing. " +
            "Add it to your .env or .env.local file."
        );
    }
    return new PublicKey(addr);
}

/** Price per mint in lamports (exact integer for 0.03 SOL) */
const PRICE_LAMPORTS = Math.round(0.03 * LAMPORTS_PER_SOL);


export default function GenerateAvatar() {

    // Generator state
    const [prompt, setPrompt] = useState("");
    const [previewUrl, setPreviewUrl] = useState<string>("");

    // Upload state
    const [uploadedFile, setUploadedFile] = useState<File | null>(null);
    const [uploadedPreviewUrl, setUploadedPreviewUrl] = useState<string>("");

    // Solana wallet and Metaplex setup
    const { publicKey, wallet, sendTransaction } = useWallet();
    const { connection } = useConnection();

    // Track which tab is active and auto-switch on generation
    const [tabValue, setTabValue] = useState<'upload' | 'generate'>('upload');
    useEffect(() => {
        if (previewUrl) {
            setTabValue('generate');
        }
    }, [previewUrl]);

    const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            setUploadedFile(file);
            setUploadedPreviewUrl(URL.createObjectURL(file));
            setPreviewUrl("");
        }
    };


    // Upload file via backend API endpoint
    async function uploadFile(file: File): Promise<string> {
        const formData = new FormData();
        formData.append("file", file);
        const res = await fetch("/api/upload-metadata", {
            method: "POST",
            body: formData,
        });
        if (!res.ok) {
            const text = await res.text();
            throw new Error(`File upload failed: ${text}`);
        }
        const { files } = await res.json();
        // assume single file upload; pick the first returned URI
        return files[0].uri;
    }

    // Fetcher for generating images without full page reload
    const fetcher = useFetcher<ActionData>();
    useEffect(() => {
        if (fetcher.data?.imageUrl) {
            setPreviewUrl(fetcher.data.imageUrl);
        }
    }, [fetcher.data]);

    const [minting, setMinting] = useState(false);

    const handleMint = async () => {
        if (!publicKey) return;

        setMinting(true);
        // Upload preview screenshot to IPFS from localStorage
        let previewIpfsUri: string;
        const blobPreview = loadBlobFromLocalStorage();
        if (!blobPreview) {
            throw new Error("No preview image found in localStorage.");
        }
        const filePreview = new File([blobPreview], 'preview.png', { type: blobPreview.type });
        // Upload and extract only the IPFS hash (strip gateway/path)
        const previewIpfsLink = await uploadFile(filePreview);
        const previewIpfsHash = previewIpfsLink.substring(previewIpfsLink.lastIndexOf('/') + 1);
        previewIpfsUri = previewIpfsHash;

        // Upload the GLB model to IPFS if present
        let modelIpfsUri = "";
        if (uploadedFile) {
            const modelIpfsLink = await uploadFile(uploadedFile);
            const modelIpfsHash = modelIpfsLink.substring(modelIpfsLink.lastIndexOf('/') + 1);
            modelIpfsUri = modelIpfsHash;
            console.log("Uploaded model hash:", modelIpfsUri);
        }
        try {
            // Prepare metadata JSON and upload to IPFS via internal API
            const metadata: NftMetadata = {
                name: `3D Avatar ${Date.now()}`,
                symbol: "AVA3D",
                description: "A unique 3D avatar NFT generated by Ekza Space",
                image: previewIpfsUri,
                animation_url: modelIpfsUri,
                attributes: [],
                properties: {
                    files: [
                        { uri: previewIpfsUri, type: "image/png" },
                        { uri: modelIpfsUri, type: "model/gltf-binary" },
                    ],
                    category: "vrmodel",
                    creators: [
                        { address: publicKey.toBase58(), share: 100 },
                    ],
                },
            };

            // Upload metadata to IPFS using internal API
            const uploadRes = await fetch("/api/upload-metadata", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(metadata),
            });
            if (!uploadRes.ok) {
                const errorText = await uploadRes.text();
                throw new Error(`Metadata upload failed: ${errorText}`);
            }
            const uploadJson = await uploadRes.json();
            const metadataUri = uploadJson.ipfsHash;
            console.log("Metadata uploaded: ", uploadJson);

            // ── Оплата ──
            if (!sendTransaction) {
                alert("Wallet is not connected or cannot send transactions.");
                setMinting(false);
                return;
            }
            const transaction = new Transaction().add(
                SystemProgram.transfer({
                    fromPubkey: publicKey,
                    toPubkey: getTreasury(), // Убедитесь, что getTreasury() не падает на клиенте, если VITE_TREASURY_ADDRESS не задан для клиентской сборки
                    lamports: PRICE_LAMPORTS,
                })
            );
            transaction.feePayer = publicKey!;
            transaction.recentBlockhash = (await connection.getLatestBlockhash("confirmed")).blockhash;

            const paymentSig = await sendTransaction(transaction, connection);
            const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
            await connection.confirmTransaction(
                { signature: paymentSig, blockhash, lastValidBlockHeight },
                "confirmed"
            );

            console.log("Client: Payment successful, paymentSig:", paymentSig);

            const body = {
                owner: publicKey.toBase58(),
                metadataUri,
                paymentSig,
            };

            console.log("Client: Sending to action:", JSON.stringify(body));

            const mintRes = await fetch(window.location.pathname, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                },
                body: JSON.stringify(body),
            });

            const responseStatus = mintRes.status;
            const responseContentType = mintRes.headers.get('content-type') || "";
            const responseText = await mintRes.text();

            console.log('Client: Response Status:', responseStatus);
            console.log('Client: Response Content-Type:', responseContentType);
            console.log('Client: Response Body (raw text):', responseText.substring(0, 1000));

            if (!mintRes.ok) {
                // Сервер вернул ошибку (4xx, 5xx)
                let errorMsg = `Server returned status ${responseStatus}.`;
                if (responseContentType.includes("application/json")) {
                    try {
                        const errJson = JSON.parse(responseText);
                        errorMsg = errJson.error || errorMsg;
                    } catch (e) { /* ignore parsing error, use status text */ }
                } else if (responseText.toLowerCase().includes("<!doctype html")) {
                    errorMsg += " Server returned an HTML error page.";
                } else {
                    errorMsg += " Response: " + responseText.substring(0, 200);
                }
                alert(`Mint failed: ${errorMsg}`);
                setMinting(false);
                return;
            }

            // mintRes.ok is true (статус 2xx)
            if (responseContentType.includes("application/json")) {
                try {
                    const mintJson = JSON.parse(responseText);
                    if (mintJson.error) { // На случай, если сервер вернул 200 OK, но с ошибкой в теле JSON
                        alert(`Mint request processed, but with error: ${mintJson.error}`);
                    } else if (mintJson.mint && mintJson.tx) {
                        alert(`✅ NFT minted successfully!\n\nView transaction:\nhttps://explorer.solana.com/tx/${mintJson.tx}?cluster=devnet\n\nMint address:\n${mintJson.mint}`);
                    } else {
                        alert(`Mint request successful, but response format is unexpected: ${JSON.stringify(mintJson)}`);
                    }
                } catch (e: any) {
                    alert(`Mint successful (HTTP ${responseStatus}) but failed to parse JSON response: ${e.message}\nRaw Response: ${responseText.substring(0, 500)}`);
                }
            } else {
                // Сервер вернул 2xx, но Content-Type не JSON - это странно для вашего случая
                alert(`Mint request successful (HTTP ${responseStatus}) but server returned unexpected content type: ${responseContentType}`);
            }

        } catch (err: any) {
            console.error("Client: Error in handleMint:", err);
            alert("Mint failed (client-side exception): " + err.message);
        } finally {
            setMinting(false);
        }
    };

    return (
        <div className="min-h-screen flex flex-col">
            {/* Header with nav + wallet */}
            <Header />

            {/* Main panel */}
            <div className="flex-1 px-8 py-4 bg-white dark:bg-gray-900">
                <Tabs.Root
                    value={tabValue}
                    onValueChange={(value) => {
                        setTabValue(value as 'upload' | 'generate');
                        setPreviewUrl('');
                        setUploadedPreviewUrl('');
                    }}
                    className="flex flex-col items-center space-y-8"
                >
                    <div className="flex items-center justify-center w-full md:w-3/4 mx-auto mb-4">
                        {uploadedFile?.name.match(/\.(glb|vrm)$/i) ? (
                            <div className="w-full max-w-xl mx-auto mb-8" style={{ aspectRatio: "16 / 10", height: "450px" }}>
                                <SceneWithModel file={URL.createObjectURL(uploadedFile)} screenshot={true} />
                            </div>
                        ) : previewUrl || uploadedPreviewUrl ? (
                            <img
                                src={previewUrl || uploadedPreviewUrl}
                                alt="Avatar preview"
                                className="w-2/3 max-w-sm aspect-square object-contain rounded-lg shadow-lg"
                            />
                        ) : (
                            <div className="w-2/3 max-w-sm aspect-square bg-gray-100 dark:bg-gray-800 rounded-lg flex items-center justify-center">
                                <span className="text-gray-500 dark:text-gray-400">
                                    Preview
                                </span>
                            </div>
                        )}
                    </div>
                    <Tabs.List className="flex space-x-4 mb-4">
                        <Tabs.Trigger
                            value="upload"
                            className="px-4 py-2 rounded-lg data-[state=active]:bg-green-500 data-[state=active]:text-white bg-gray-200 dark:bg-gray-700 text-gray-500 dark:text-gray-300 transition-colors"
                        >
                            Upload
                        </Tabs.Trigger>
                        <Tabs.Trigger
                            value="generate"
                            className="px-4 py-2 rounded-lg data-[state=active]:bg-green-500 data-[state=active]:text-white bg-gray-200 dark:bg-gray-700 text-gray-500 dark:text-gray-300 transition-colors"
                        >
                            Generate
                        </Tabs.Trigger>
                    </Tabs.List>

                    <Tabs.Content value="generate" className="w-full flex flex-col space-y-8 items-center">
                        <fetcher.Form method="post" className="w-full flex flex-col items-center space-y-4">
                            <textarea
                                name="prompt"
                                value={prompt}
                                onChange={(e) => setPrompt(e.target.value)}
                                placeholder="Describe the avatar you want…"
                                rows={4}
                                className="w-2/3 max-w-sm bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg px-4 py-2 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-purple-500"
                            />
                            <button
                                onClick={() => alert("Sorry, this feature still in progress.")}
                                type="button"
                                className="w-1/4 px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 focus:outline-none focus:ring-4 focus:ring-green-300 transition-colors duration-200"
                            >
                                Generate
                            </button>
                            {!publicKey && (
                                <p className="text-sm text-red-500">
                                    Connect your wallet to generate.
                                </p>
                            )}
                        </fetcher.Form>
                        {(previewUrl || uploadedPreviewUrl) && publicKey && (
                            <button
                                onClick={handleMint}
                                disabled={minting}
                                className={`w-1/4 px-4 py-2 ${minting ? "bg-gray-400" : "bg-blue-500 hover:bg-blue-600"} text-white font-semibold rounded-lg shadow-md focus:outline-none focus:ring-4 focus:ring-blue-300 transition-colors duration-200`}
                            >
                                {minting ? "Minting..." : "Mint"}
                            </button>
                        )}
                    </Tabs.Content>

                    <Tabs.Content value="upload" className="w-full flex flex-col space-y-4 items-center">
                      <input
                            type="file"
                            accept=".vrm,.glb,model/gltf-binary"
                            onChange={handleFileChange}
                            className="w-2/3 max-w-sm bg-gray-50 dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg p-4"
                        />
                      <p className="mt-2 text-sm text-gray-500 dark:text-gray-400">
                          Use a sample models to explore the interface: <a href="https://drive.google.com/drive/folders/11oQ8pwVMV9inSVV9cGceI8xTusDxhPC3?usp=drive_link" target="_blank" rel="noopener noreferrer" className="text-blue-500 hover:underline">download here</a>
                      </p>
                        {(uploadedPreviewUrl || previewUrl) && publicKey && (
                            <button
                                onClick={handleMint}
                                disabled={minting}
                                className={`w-1/4 px-4 py-2 ${minting ? "bg-gray-400" : "bg-blue-500 hover:bg-blue-600"} text-white font-semibold rounded-lg shadow-md focus:outline-none focus:ring-4 focus:ring-blue-300 transition-colors duration-200`}
                            >
                                {minting ? "Minting..." : "Mint"}
                            </button>
                        )}
                    </Tabs.Content>
                </Tabs.Root>
            </div>
        </div>
    );
}

export async function action({ request }: ActionFunctionArgs) {
    const contentType = request.headers.get("content-type") || "";

    // ───────────────────────────────────────────────────────────
    // 1) JSON branch → called from handleMint (minting request)
    // ───────────────────────────────────────────────────────────
    if (contentType.includes("application/json")) {
        const { owner, metadataUri, paymentSig } = await request.json();
        console.log("Minting: ", metadataUri)

        if (!owner || !metadataUri || !paymentSig) {
            return Response.json({ error: "Missing owner, metadataUri or paymentSig" }, { status: 400 });
        }

        /* ---------------------------------------------------------
           1) Verify that `paymentSig` really transfers PRICE_LAMPORTS
              from `owner` to our treasury address.
        --------------------------------------------------------- */
        try {
            const conn = new Connection(clusterApiUrl("devnet"), "confirmed");
            // @ts-ignore use parsed transaction to access .program and .parsed
            const txInfo = await conn.getParsedTransaction(paymentSig, "confirmed");
            // @ts-ignore treat instructions as parsed objects
            const instructions: any[] = (txInfo as any).transaction.message.instructions;

            if (!txInfo) {
                return Response.json({ error: "Payment transaction not found on chain" }, { status: 400 });
            }

            const treasury = getTreasury().toBase58();
            let paymentVerified = false;

            for (const instr of instructions) {
                if ("parsed" in instr && instr.program === "system") {
                    const info: any = instr.parsed.info;
                    if (
                        info.destination === treasury &&
                        info.source === owner &&
                        Number(info.lamports) >= PRICE_LAMPORTS
                    ) {
                        paymentVerified = true;
                        break;
                    }
                }
            }

            if (!paymentVerified) {
                return Response.json({ error: "Payment to treasury not found or amount too low" }, { status: 400 });
            }

            // ── Load server admin secret key and configure Umi signer ──
            const rawKey = process.env.ADMIN_KEYPAIR!;
            let secretArr: number[];
            if (rawKey.trim().startsWith("[")) {
                // Env var contains the JSON array directly
                secretArr = JSON.parse(rawKey) as number[];
            } else {
                // Env var is a path to the keypair file
                const fs = await import("fs");
                secretArr = JSON.parse(fs.readFileSync(rawKey, "utf-8")) as number[];
            }
            const secretBytes = Uint8Array.from(secretArr);
            const {
                createSignerFromKeypair,
                keypairIdentity,
                generateSigner,
                percentAmount,
                publicKey,
            } = await import("@metaplex-foundation/umi");

            /* -----------------------------------------------------
               2) Mint the NFT on the server with Metaplex Umi
            ----------------------------------------------------- */
            const { createUmi } = await import("@metaplex-foundation/umi-bundle-defaults");
            const { createNft, mplTokenMetadata } = await import("@metaplex-foundation/mpl-token-metadata");

            // Use the same endpoint as the client (devnet by default)
            const umi = createUmi(clusterApiUrl("devnet"));

            // Convert to Umi keypair and register it as the signer
            const umiKeypair = umi.eddsa.createKeypairFromSecretKey(secretBytes);
            const signer = createSignerFromKeypair(umi, umiKeypair);
            umi.use(keypairIdentity(signer)).use(mplTokenMetadata());

            // Now generate a mint keypair and mint
            const mint = generateSigner(umi);

            const { signature: mintSig } = await createNft(umi, {
                mint,
                name: "w3avatar",
                symbol: "ekza",
                uri: metadataUri,
                sellerFeeBasisPoints: percentAmount(5.5),
                tokenOwner: publicKey(owner),
            }).sendAndConfirm(umi);

            console.log("✅ NFT minted:", mint.publicKey.toString(), "tx:", mintSig);

            return Response.json({
                status: "minted",
                mint: mint.publicKey.toString(),
                tx: mintSig,
            });
        } catch (e: any) {
            console.error("Mint failed on backend:", e);
            return Response.json({ error: "Minting failed on backend: " + e.message }, { status: 500 });
        }
    }

    // ───────────────────────────────────────────────────────────
    // 2) formData branch → called from the "Generate" textarea
    // ───────────────────────────────────────────────────────────
    if (contentType.includes("multipart/form-data") || contentType.includes("application/x-www-form-urlencoded")) {
        const formData = await request.formData();
        const prompt = formData.get("prompt");
        console.log("Received prompt:", prompt);

        // TODO: replace with real image generation logic
        const generatedImageUrl = "https://ipfs.io/ipfs/QmbCrNSEck2ZMGxoVJBMcsxF6fdiaGxCiSykxD8HLCKxbF";

        return Response.json({ imageUrl: generatedImageUrl });
    }

    // Unsupported content type
    return new Response("Unsupported Content‑Type", { status: 415 });
}