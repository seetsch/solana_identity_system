import * as anchor from "@coral-xyz/anchor";
import { Program, web3, BN } from "@coral-xyz/anchor";
import {
    PublicKey,
    SystemProgram,
    SYSVAR_RENT_PUBKEY,
    Keypair,
    Signer,
    Connection
} from "@solana/web3.js";
import {
    TOKEN_PROGRAM_ID,
    ASSOCIATED_TOKEN_PROGRAM_ID,
    getAssociatedTokenAddressSync,
} from "@solana/spl-token";
import { MPL_TOKEN_METADATA_PROGRAM_ID } from "@metaplex-foundation/mpl-token-metadata";

// 1. Import the TYPE generated by Anchor:
// Ensure this path is correct for your project structure.
// It should point to the .ts file generated in your target/types/ directory
import type { AvatarNftMinter as AvatarNftMinterIDLType } from "../idl/avatar_nft_minter"; // Assuming avatar_nft_minter.ts is in idl/

// 2. Import the JSON IDL:
import idlJson from "../idl/avatar_nft_minter.json";

// 3. Create a correctly typed IDL constant:
const TYPED_IDL = idlJson as AvatarNftMinterIDLType; // Cast the JSON to the generated type
const METADATA_PROGRAM_ID = new PublicKey(MPL_TOKEN_METADATA_PROGRAM_ID);

// --- Constants ---
// Use the top-level 'address' from the JSON IDL
export const PROGRAM_ID = new PublicKey(TYPED_IDL.address);
const METADATA_SEED = "metadata";
const AVATAR_PDA_SEED = "avatar_v1";
const REGISTRY_PDA_SEED = "avatar_registry";

// --- Interfaces ---
export type AvatarDataAccount = anchor.IdlAccounts<AvatarNftMinterIDLType>['avatarData'];
export type AvatarRegistryAccount = anchor.IdlAccounts<AvatarNftMinterIDLType>['avatarRegistry'];

const ESCROW_PDA_SEED = "avatar_escrow";


// --- SDK Client Class ---
export class AvatarNftMinterClient {
    public program: Program<AvatarNftMinterIDLType>; // Use the specific IDL Type
    public provider: anchor.AnchorProvider;

    constructor(
        provider: anchor.AnchorProvider,
        programId: PublicKey = PROGRAM_ID // Use the constant defined above
    ) {
        this.provider = provider;
        // Pass the TYPED_IDL and the specific programId
        // this.program = new Program<AvatarNftMinterIDLType>(TYPED_IDL, programId, provider);
        this.program = anchor.workspace.avatarNftMinter as Program<AvatarNftMinterIDLType>
    }

    // --- PDA Derivation ---

    public getAvatarDataPda(index: number): [PublicKey, number] {
        return PublicKey.findProgramAddressSync(
            [Buffer.from("avatar_v1"), new BN(index).toArrayLike(Buffer, "le", 8)],
            this.program.programId
        );
    }

    public getEscrowPda(index: number): [PublicKey, number] {
        return PublicKey.findProgramAddressSync(
            [Buffer.from("avatar_escrow"), new BN(index).toArrayLike(Buffer, "le", 8)],
            this.program.programId
        );
    }


    public getMetadataPda(mintPublicKey: PublicKey): [PublicKey, number] {
        return PublicKey.findProgramAddressSync(
            [
                Buffer.from(METADATA_SEED),
                METADATA_PROGRAM_ID.toBuffer(),
                mintPublicKey.toBuffer(),
            ],
            METADATA_PROGRAM_ID
        );
    }

    // --- Instructions ---

    async initializeAvatar(
        payer: Signer,
        ipfsHash: string,
        maxSupply: BN,
        mintingFeePerMint: BN
    ): Promise<{ signature: string; avatarDataPda: PublicKey }> {
        // Derive registry PDA (holds the running avatar index)
        const [registryPda] = PublicKey.findProgramAddressSync(
            [Buffer.from(REGISTRY_PDA_SEED)],
            this.program.programId
        );

        // Try to fetch the registry; if it does not exist yet we start with index 0
        let nextIndex: number;
        try {
            const registryAccount = await this.program.account.avatarRegistry.fetch(registryPda);
            nextIndex = registryAccount.nextIndex.toNumber();
        } catch (_e) {
            // Registry wasn't created yet – we'll initialise it implicitly in the
            // program and start counting from zero.
            nextIndex = 0;
        }

        const [avatarDataPda] = this.getAvatarDataPda(nextIndex);
        const [escrowPda] = this.getEscrowPda(nextIndex);
        const signature = await this.program.methods
            .initializeAvatar(ipfsHash, maxSupply, mintingFeePerMint)
            .accountsStrict({
                registry:  registryPda,
                avatarData: avatarDataPda,
                payer:      payer.publicKey,
                escrow:     escrowPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([payer])
            .rpc();

        return { signature, avatarDataPda };
    }

    async mintNft(
        minter: Signer,
        index: number,
        name: string,
        symbol: string,
        uri: string,
        mintKeypair?: Keypair
    ): Promise<{
        signature: string;
        mintPk: PublicKey;
        tokenAccountPk: PublicKey;
        metadataPk: PublicKey;
    }> {
        const [avatarDataPda] = this.getAvatarDataPda(index);
        const [escrowPda] = this.getEscrowPda(index);
        const mint = mintKeypair || Keypair.generate();
        const tokenAccount = getAssociatedTokenAddressSync(
            mint.publicKey,
            minter.publicKey
        );
        const [metadataPda] = this.getMetadataPda(mint.publicKey);

        const signers = [minter, mint];

        const signature = await this.program.methods
            .mintNft(name, symbol, uri)
            .accountsStrict({
                avatarData: avatarDataPda,
                mint: mint.publicKey,
                tokenAccount: tokenAccount,
                metadataAccount: metadataPda,
                payer: minter.publicKey,
                escrow: escrowPda,
                tokenProgram: TOKEN_PROGRAM_ID,
                associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
                tokenMetadataProgram: MPL_TOKEN_METADATA_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                rent: SYSVAR_RENT_PUBKEY,
            })
            .signers(signers)
            .rpc();

        return {
            signature,
            mintPk: mint.publicKey,
            tokenAccountPk: tokenAccount,
            metadataPk: metadataPda,
        };
    }

    /**
     * Convenience wrapper for front‑end usage when you only have the connected
     * wallet (via AnchorProvider) and its public key – i.e. **no Keypair signer**
     * for the user. The wallet itself will sign the transaction automatically;
     * we only need to sign with the freshly‑generated mint keypair.
     */
    async mintNftWithWallet(
        minterPublicKey: PublicKey,
        index: number,
        name: string,
        symbol: string,
        uri: string,
        mintKeypair?: Keypair
    ): Promise<{
        signature: string;
        mintPk: PublicKey;
        tokenAccountPk: PublicKey;
        metadataPk: PublicKey;
    }> {
        const mint = mintKeypair || Keypair.generate();
        const tokenAccount = getAssociatedTokenAddressSync(
            mint.publicKey,
            minterPublicKey
        );
        const [metadataPda] = this.getMetadataPda(mint.publicKey);
        const [avatarDataPda] = this.getAvatarDataPda(index);
        const [escrowPda] = this.getEscrowPda(index);

        const signature = await this.program.methods
            .mintNft(name, symbol, uri)
            .accountsStrict({
                avatarData: avatarDataPda,
                mint: mint.publicKey,
                tokenAccount,
                metadataAccount: metadataPda,
                payer: minterPublicKey,
                escrow: escrowPda,
                tokenProgram: TOKEN_PROGRAM_ID,
                associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
                tokenMetadataProgram: MPL_TOKEN_METADATA_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                rent: SYSVAR_RENT_PUBKEY,
            })
            // wallet (provider.wallet) will sign automatically; only the mint keypair
            // needs to be supplied in `signers`
            .signers([mint])
            .rpc();

        return {
            signature,
            mintPk: mint.publicKey,
            tokenAccountPk: tokenAccount,
            metadataPk: metadataPda,
        };
    }

    async claimFee(
        creatorSigner: Signer, // Renamed for clarity, this is the 'creator' account from IDL
        index: number
    ): Promise<{ signature: string }> {
        const [avatarDataPda] = this.getAvatarDataPda(index);
        const [escrowPda] = this.getEscrowPda(index);

        const signature = await this.program.methods
            .claimFee()
            .accounts({
                avatarData: avatarDataPda, // Matches 'avatar_data' in IDL
                creator: creatorSigner.publicKey, // Matches 'creator' account in IDL
                escrow: escrowPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([creatorSigner])
            .rpc();

        return { signature };
    }

    // --- Account Fetchers ---
    async getAvatarData(
        avatarDataPda: PublicKey
    ): Promise<AvatarDataAccount | null> {
        try {
            const data = await this.program.account.avatarData.fetch(avatarDataPda);
            return data; // No need for 'as AvatarDataAccount' if program is correctly typed
        } catch (e: unknown) {
            let errorMessage = "";
            if (e instanceof Error) {
                errorMessage = e.message;
            } else if (typeof e === 'object' && e !== null && 'message' in e && typeof (e as { message: string }).message === 'string') {
                errorMessage = (e as { message: string }).message;
            } else if (typeof e === 'string') {
                errorMessage = e;
            }

            if (
                errorMessage.includes("Account does not exist") ||
                errorMessage.includes("could not be found") ||
                errorMessage.includes("Account not found") ||
                errorMessage.toLowerCase().includes("failed to get account info")
            ) {
                return null;
            }
            throw e;
        }
    }

    /**
     * Fetch the AvatarRegistry account (if it exists).
     * @returns `{ registryPda, registry }` where `registry` is null if the account is absent.
     */
    async getAvatarRegistry(): Promise<{ registryPda: PublicKey; registry: AvatarRegistryAccount | null }> {
        const [registryPda] = PublicKey.findProgramAddressSync(
            [Buffer.from(REGISTRY_PDA_SEED)],
            this.program.programId,
        );

        try {
            const registry = await this.program.account.avatarRegistry.fetch(registryPda);
            return { registryPda, registry };
        } catch (_e) {
            // Registry not yet created
            return { registryPda, registry: null };
        }
    }

    /**
     * Fetch all existing AvatarData PDAs by iterating from 0 to `nextIndex - 1`.
     * Skips any missing or corrupted PDAs.
     */
    async getAllAvatarData(): Promise<{ index: number; data: AvatarDataAccount }[]> {
        const { registry } = await this.getAvatarRegistry();
        const results: { index: number; data: AvatarDataAccount }[] = [];

        const maxIndex = registry ? registry.nextIndex.toNumber() : 0;
        for (let i = 0; i < maxIndex; i++) {
            const [avatarDataPda] = this.getAvatarDataPda(i);
            try {
                const data = await this.program.account.avatarData.fetch(avatarDataPda);
                results.push({ index: i, data });
            } catch (_e) {
                // Avatar PDA might be missing (e.g., failed init). Ignore and continue.
                continue;
            }
        }

        return results;
    }
}

export function getAvatarNftMinterClient(
    connection: Connection,
    wallet: anchor.Wallet,
    programId?: PublicKey
): AvatarNftMinterClient {
    const provider = new anchor.AnchorProvider(
        connection,
        wallet,
        anchor.AnchorProvider.defaultOptions()
    );
    return new AvatarNftMinterClient(provider, programId);
}