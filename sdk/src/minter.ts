import * as anchor from "@coral-xyz/anchor";
import { Program, web3, BN } from "@coral-xyz/anchor";
import {
    PublicKey,
    SystemProgram,
    SYSVAR_RENT_PUBKEY,
    Keypair,
    Signer,
    Connection
} from "@solana/web3.js";
import {
    TOKEN_PROGRAM_ID,
    ASSOCIATED_TOKEN_PROGRAM_ID,
    getAssociatedTokenAddressSync,
} from "@solana/spl-token";
import { MPL_TOKEN_METADATA_PROGRAM_ID } from "@metaplex-foundation/mpl-token-metadata";

// 1. Import the TYPE generated by Anchor:
// Ensure this path is correct for your project structure.
// It should point to the .ts file generated in your target/types/ directory
import type { AvatarNftMinter as AvatarNftMinterIDLType } from "../idl/avatar_nft_minter"; // Assuming avatar_nft_minter.ts is in idl/

// 2. Import the JSON IDL:
import idlJson from "../idl/avatar_nft_minter.json";
import { sha256 } from "js-sha256";

// 3. Create a correctly typed IDL constant:
const TYPED_IDL = idlJson as AvatarNftMinterIDLType; // Cast the JSON to the generated type
const METADATA_PROGRAM_ID = new PublicKey(MPL_TOKEN_METADATA_PROGRAM_ID);

// --- Constants ---
// Use the top-level 'address' from the JSON IDL
export const PROGRAM_ID = new PublicKey(TYPED_IDL.address);
const METADATA_SEED = "metadata";
const AVATAR_PDA_SEED = "avatar_v1";

// --- Interfaces ---
export type AvatarDataAccount = anchor.IdlAccounts<AvatarNftMinterIDLType>['avatarData'];

const ESCROW_PDA_SEED = "avatar_escrow";


// --- SDK Client Class ---
export class AvatarNftMinterClient {
    public program: Program<AvatarNftMinterIDLType>; // Use the specific IDL Type
    public provider: anchor.AnchorProvider;

    constructor(
        provider: anchor.AnchorProvider,
        programId: PublicKey = PROGRAM_ID // Use the constant defined above
    ) {
        this.provider = provider;
        // Pass the TYPED_IDL and the specific programId
        // this.program = new Program<AvatarNftMinterIDLType>(TYPED_IDL, programId, provider);
        this.program = anchor.workspace.avatarNftMinter as Program<AvatarNftMinterIDLType>
    }

    // ... (rest of your class methods should now be correctly typed)
    // Make sure account names in .accounts({}) match the camelCased versions from your IDL.
    // e.g., avatar_data in Rust/IDL becomes avatarData in TS.

    // --- PDA Derivation ---

    public getAvatarDataPda(ipfsHash: string): [PublicKey, number] {
        const digest = Buffer.from(sha256.arrayBuffer(ipfsHash));
        return PublicKey.findProgramAddressSync(
            [Buffer.from(AVATAR_PDA_SEED), digest],
            this.program.programId
        );
    }

    public getEscrowPda(ipfsHash: string): [PublicKey, number] {
      const digest = Buffer.from(sha256.arrayBuffer(ipfsHash));
      return PublicKey.findProgramAddressSync(
        [Buffer.from(ESCROW_PDA_SEED), digest],
        this.program.programId
      );
    }


    public getMetadataPda(mintPublicKey: PublicKey): [PublicKey, number] {
        return PublicKey.findProgramAddressSync(
            [
                Buffer.from(METADATA_SEED),
                METADATA_PROGRAM_ID.toBuffer(),
                mintPublicKey.toBuffer(),
            ],
            METADATA_PROGRAM_ID
        );
    }

    // --- Instructions ---

    async initializeAvatar(
        payer: Signer,
        ipfsHash: string,
        maxSupply: BN,
        mintingFeePerMint: BN
    ): Promise<{ signature: string; avatarDataPda: PublicKey }> {
        const [avatarDataPda] = this.getAvatarDataPda(ipfsHash);
        const [escrowPda] = this.getEscrowPda(ipfsHash);
        const signature = await this.program.methods
            .initializeAvatar(ipfsHash, maxSupply, mintingFeePerMint)
            .accountsStrict({
                avatarData: avatarDataPda,
                payer: payer.publicKey,
                escrow: escrowPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([payer])
            .rpc();

        return { signature, avatarDataPda };
    }

    async mintNft(
        minter: Signer,
        ipfsHash: string,
        name: string,
        symbol: string,
        uri: string,
        mintKeypair?: Keypair
    ): Promise<{
        signature: string;
        mintPk: PublicKey;
        tokenAccountPk: PublicKey;
        metadataPk: PublicKey;
    }> {
        const [avatarDataPda] = this.getAvatarDataPda(ipfsHash);
        const [escrowPda] = this.getEscrowPda(ipfsHash);
        const mint = mintKeypair || Keypair.generate();
        const tokenAccount = getAssociatedTokenAddressSync(
            mint.publicKey,
            minter.publicKey
        );
        const [metadataPda] = this.getMetadataPda(mint.publicKey);

        const signers = [minter, mint];

        const signature = await this.program.methods
            .mintNft(name, symbol, uri)
            .accountsStrict({
                avatarData: avatarDataPda,
                mint: mint.publicKey,
                tokenAccount: tokenAccount,
                metadataAccount: metadataPda,
                payer: minter.publicKey,
                escrow: escrowPda,
                tokenProgram: TOKEN_PROGRAM_ID,
                associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
                tokenMetadataProgram: MPL_TOKEN_METADATA_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                rent: SYSVAR_RENT_PUBKEY,
            })
            .signers(signers)
            .rpc();

        return {
            signature,
            mintPk: mint.publicKey,
            tokenAccountPk: tokenAccount,
            metadataPk: metadataPda,
        };
    }

    async claimFee(
        creatorSigner: Signer, // Renamed for clarity, this is the 'creator' account from IDL
        ipfsHash: string
    ): Promise<{ signature: string }> {
        const [avatarDataPda] = this.getAvatarDataPda(ipfsHash);
        const [escrowPda] = this.getEscrowPda(ipfsHash);

        const signature = await this.program.methods
            .claimFee()
            .accounts({
                avatarData: avatarDataPda, // Matches 'avatar_data' in IDL
                creator: creatorSigner.publicKey, // Matches 'creator' account in IDL
                escrow: escrowPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([creatorSigner])
            .rpc();

        return { signature };
    }

    // --- Account Fetchers ---
    async getAvatarData(
        avatarDataPda: PublicKey
    ): Promise<AvatarDataAccount | null> {
        try {
            const data = await this.program.account.avatarData.fetch(avatarDataPda);
            return data; // No need for 'as AvatarDataAccount' if program is correctly typed
        } catch (e: unknown) {
            let errorMessage = "";
            if (e instanceof Error) {
                errorMessage = e.message;
            } else if (typeof e === 'object' && e !== null && 'message' in e && typeof (e as { message: string }).message === 'string') {
                errorMessage = (e as { message: string }).message;
            } else if (typeof e === 'string') {
                errorMessage = e;
            }

            if (
                errorMessage.includes("Account does not exist") ||
                errorMessage.includes("could not be found") ||
                errorMessage.includes("Account not found") ||
                errorMessage.toLowerCase().includes("failed to get account info")
            ) {
                return null;
            }
            throw e;
        }
    }
}

export function getAvatarNftMinterClient(
    connection: Connection,
    wallet: anchor.Wallet,
    programId?: PublicKey
): AvatarNftMinterClient {
    const provider = new anchor.AnchorProvider(
        connection,
        wallet,
        anchor.AnchorProvider.defaultOptions()
    );
    return new AvatarNftMinterClient(provider, programId);
}